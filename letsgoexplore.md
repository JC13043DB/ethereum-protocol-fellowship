---
timezone: Asia/Shanghai
---


# Jason Zhao

1. 自我介绍 
    - Researcher, Developer, Buidler | defi & cryptography & consensus
    - 试图和ETH一样有趣（不是说价格lol
    - 坐标hk海边
    - 喜欢到处跑，喜欢和大家聊天
    - Let's go explore!
2. 你认为你会完成本次残酷学习吗？ 
    - Passion!

## Notes

<!-- Content_START -->

### 2025.02.06

`Reading Focus`
- ETH中的存储结构

`核心问题`
- Patricia Tree 的机制，如何提升效率的？
- Verkle Tree 与 MPT 的对比?
- ETH的MPT(Merkle Patricia Tree)的节点上都是什么？是用户的状态还是交易内容？
- 这二者以及blob的存储状态、读取状态有何不同？

`核心内容`
- Patricia Tree 的机制，如何提升效率的？
**节点类型与结构**：
  - **分支节点（Branch Node）**：包含 17 个槽位（16 个十六进制字符分支 + 1 个值槽位），用于存储子节点路径。
  - **扩展节点（Extension Node）**：存储**共享前缀**和一个子节点的哈希引用，用于合并具有相同前缀的键。
  - **叶子节点（Leaf Node）**：存储键的剩余部分（后缀）及其关联的值。

**路径压缩**：
  - 当多个键具有相同前缀时，Patricia Tree 会将这些键的公共前缀合并为一个扩展节点，避免重复存储。
  - 例如，键 `0x1234` 和 `0x1235` 的公共前缀 `0x123` 会被合并到一个扩展节点中，仅存储一次。

**查找流程**：
  1. 从根节点开始，按路径逐字符匹配。
  2. 遇到扩展节点时，跳过共享前缀，直接跳转到子节点。
  3. 最终在叶子节点中匹配剩余后缀，获取值。

**效率提升的关键**
- **存储优化**：通过共享前缀减少冗余存储，树的高度显著降低。
- **查找加速**：路径压缩减少遍历的节点数，复杂度从普通 Trie 的 `O(k)`（k 为键长）优化至接近 `O(log n)`。
- **空间效率**：避免稀疏存储（普通 Trie 的空分支占用空间），仅存储有效路径。

- Verkle Tree 与 MPT 的对比

| 特性 | MPT | Verkle Tree |
| --- | --- | --- |
| 证明大小 | O(log₂n) | O(logₖn) |
| 数据结构 | 哈希树 + 前缀树 | 向量承诺 + 前缀树 |
| 验证效率 | 较高 | 更高 |
| 适用场景 | 中小规模数据 | 大规模数据和高并发场景 |
| 无状态性支持 | 有限 | 完全支持 |


- 用户状态 vs 交易内容 vs Blob

| 树类型       | 存储内容                          | 用途                                 |
|--------------|-----------------------------------|--------------------------------------|
| **状态树**   | 账户状态（地址 → 余额、nonce 等） | 全局状态管理，每个区块更新一次根哈希 |
| **交易树**   | 区块中的交易列表                  | 验证交易是否存在于特定区块           |
| **收据树**   | 交易执行后的收据（日志、Gas 消耗）| 提供交易执行结果的证明               |
| **Storage 树** | 合约的存储变量（键值对）          | 每个合约账户独立维护一个 Storage 树  |


| 数据类型     | 存储结构      | 持久性       | 读取方式                         |
|--------------|---------------|--------------|----------------------------------|
| **用户状态** | MPT（状态树） | 长期持久化   | 通过地址直接查询状态树           |
| **交易内容** | MPT（交易树） | 永久存储     | 通过区块号+索引查询交易树        |
| **Blob 数据** | 临时链外存储  | 短期保留     | 通过 EIP-4844 的 `blob` 接口访问 |

| 数据         | 存储位置                | 更新频率       | 验证方式                     |
|--------------|-------------------------|----------------|------------------------------|
| **用户状态** | 状态树（MPT）           | 每区块更新     | 通过 Merkle 证明验证最新状态 |
| **交易内容** | 交易树（MPT）           | 仅写入一次     | 通过区块头哈希验证存在性     |
| **Blob**     | 链外存储（非 MPT）      | 临时写入       | 通过数据哈希验证完整性       |

### 2025.02.07
`Reading Focus`
- ETH的执行层(1)

`核心问题`
- 执行层模型
<!-- - 执行层组件 -->

`核心内容`
- 执行层模型
  - 紧接着我们昨天的存储结构，以太坊的状态存储采用了 **状态树（State Trie）和存储树（Storage Trie）** 等数据结构。为了优化存储和性能，以太坊引入了状态修剪（State Pruning）机制。
  - ETH执行层是一个状态机模型，状态转移函数包括：
    - **对于存储树的操作**： 前一个Header的获取函数；
    - **对于状态树的操作**： 对于当前块的255个块之前的块在状态树中进行剪枝；
    - **核心操作**：
      - Header验证函数
      - blob验证函数
      - 叔块检查函数(有趣的是它已经更名为ommers block)
      - 交易执行函数
        - 检查Gas消耗
        - 生成所有交易的日志的布隆过滤器
        - 生成trie root(前缀树根)
<!-- - 执行层组件 -->

笔记内容
